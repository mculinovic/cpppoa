/**
 * @file graph.hpp
 * @author Marko Culinovic <marko.culinovic@gmail.com>
 * @brief Graph class header file 
 * @details Header file with declaration of Graph class used for
 * partial order alignment algorithm. Class is
 * based on https://github.com/ljdursi/poapy/blob/master/poagraph.py
 * Graph class python implementation
 */
#ifndef GRAPH_H
#define GRAPH_H

#include <string>
#include <vector>
#include <memory>
#include <unordered_set>
#include <utility>

#include "./node.hpp"
#include "./edge.hpp"
#include "./alignment.hpp"

using std::vector;
using std::string;
using std::shared_ptr;
using std::unordered_set;
using std::pair;

namespace POA {

    class Node;
    class Edge;
    class Alignment;

    class Graph {
     public:
        /**
         * @brief Graph constructor
         * @details Constructor of directed acyclic graph.
         * Creates graph from sequence given as parameter.
         *
         * @param seq sequence
         * @param label sequence labal
         */
        Graph(const string& seq, const string& label);

        /**
         * @brief Adds Node to graph
         * @details Method constructs new Node with
         * base given as parameter and adds it to graph.
         *
         * @param base nucleotid(base)
         */
        void addNode(char base);


        /**
         * @brief Adds Edge to graph
         * @details Method constructs new edge connecting
         * nodes with ids given as parameters.
         *
         * @param id_A start node id
         * @param id_B end node id
         * @param label label of sequence which passes through this edge
         */
        void addEdge(uint32_t id_A, uint32_t id_B, const string& label);


        /**
         * @brief Getter for Node with given id
         *
         * @param id node id
         * @return pointer to node
         */
        const shared_ptr<Node>& getNode(uint32_t id) const;


        /**
         * @brief Method returns topologicaly sorted node ids
         * @details If graph isn't toplogicaly sorted, method
         * invokes topological_sort method on graph and returns
         * sorted ids, otherwise ids are already sorted so it
         * only returns them
         * @return sorted node ids
         */
        const vector<uint32_t>& getNodesIds();


        /**
         * @brief Getter for all nodes in graph
         * @return vector of pointers to all nodes in graph
         */
        const vector<shared_ptr< Node >>& getNodes() const;


        /**
         * @return number of nodes in graph
         */
        uint32_t getNodesNum() const;


        /**
         * @brief Adds unmatched sequence to graph
         * @details Insert sequence unaligned to any nodes in
         * graph to a graph. It does so by creating new nodes
         * for each character in sequence
         * 
         * @param sequence unmatched sequence to be added into graph
         * @param label sequence label
         * @param update flag set to true if sequence isn't yet in graph,
         * false otherwise
         * @return start and end node ids of sequence after insertion in graph
         */
        pair<uint32_t, uint32_t> addUnmatchedSequence(const string& sequence,
                                                      const string& label,
                                                      bool update);


        /**
         * @brief Insert new sequence into graph
         * @details Method inserts new sequence into graph
         * based on data given by alignment of this sequence
         * to graph
         * 
         * @param alignment alignment data between sequence and graph
         * @param seq sequence
         * @param label sequence label
         */
        void insertSequenceAlignment(const Alignment& alignment,
                                     const string& seq,
                                     const string& label);


        /**
         * @brief method outputs alignment strings to stdout
         */
        void alignment_strings();


        /**
         * @brief method generates consensus sequence
         * @details consensus sequence is generated by
         * finding maximum weight path in graph
         * 
         * @param pconsensus string to store consensus sequence
         */
        void generate_consensus(string *pconsensus);


        /**
         * @brief returns precalculated maximum node distance from the very start
         * @details after every topological sort, values are recalculated
         * 
         * @param node_id node id
         */
        int max_node_distance(const int node_id) const;

        /**
         * @brief returns precalculated minimum node distance from the very start
         * @details after every topological sort, values are recalculated
         * 
         * @param node_id node id
         */
        int min_node_distance(const int node_id) const;

     private:
        /**
         * @brief Depth-first search method
         * @details http://en.wikipedia.org/wiki/Depth-first_search
         * 
         * @param start_id id of search start node
         */
        void DFS(uint32_t start_id);

        /**
         * @brief Topological sort of graph nodes
         * @details http://en.wikipedia.org/wiki/Topological_sorting
         */
        void topological_sort();

        /**
         * @brief fills node_distance_
         * @details must be run when is_sorted == true
         */
        void calc_nodes_distances();

        // vector of graph nodes
        vector<shared_ptr< Node >> nodes_;
        // id of next node to be added to graph
        uint32_t next_id_;

        // container for storing sorted node ids
        vector<uint32_t> nodes_order_;
        // helper set for topological sort
        unordered_set<uint32_t> visited_;
        // sort flat
        bool is_sorted;

        // sequences stored in graph
        vector<string> sequences_;
        // sequences labels
        vector<string> labels_;
        // start node ids for every sequence
        vector<int> start_ids_;

        // maximum distance of every node (from start node)
        vector<int> max_node_distance_;
        // minimum distance of every node (from start node)
        vector<int> min_node_distance_;
    };
}

#endif  // GRAPH_H
